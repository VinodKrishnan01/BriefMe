// Firestore Security Rules for Brief Generator (Production with Authentication)
// Use these rules when you implement user authentication in production

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Custom function to validate client session ID format (UUID)
    function isValidClientSessionId(sessionId) {
      return sessionId is string && 
             sessionId.size() == 36 && 
             sessionId.matches('[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}');
    }
    
    // Custom function to validate brief data structure
    function isValidBriefData(data) {
      return data.keys().hasAll(['client_session_id', 'source_text', 'summary', 'decisions', 'actions', 'questions', 'sha256', 'created_at', 'user_id']) &&
             data.client_session_id is string &&
             data.user_id is string &&
             data.source_text is string &&
             data.source_text.size() > 0 &&
             data.source_text.size() <= 10000 &&
             data.summary is string &&
             data.decisions is list &&
             data.actions is list &&
             data.questions is list &&
             data.sha256 is string &&
             data.created_at is timestamp;
    }
    
    // Custom function to validate action item structure
    function isValidAction(action) {
      return action is map &&
             'text' in action &&
             action.text is string &&
             action.text.size() > 0 &&
             (action.keys().hasOnly(['text']) ||
              action.keys().hasOnly(['text', 'owner']) ||
              action.keys().hasOnly(['text', 'due_date']) ||
              action.keys().hasOnly(['text', 'owner', 'due_date']));
    }
    
    // Custom function to validate all actions in the list
    function areValidActions(actions) {
      return actions.size() <= 100 && // Reasonable limit
             actions.hasOnly(isValidAction);
    }
    
    // Custom function to check if user owns the brief
    function isOwner(resource) {
      return request.auth != null &&
             request.auth.uid == resource.data.user_id;
    }
    
    // Rules for briefs collection
    match /briefs/{briefId} {
      // Allow read only if user is authenticated and owns the brief
      allow read: if request.auth != null &&
                     isOwner(resource) &&
                     isValidClientSessionId(resource.data.client_session_id);
      
      // Allow create with authentication and proper data validation
      allow create: if request.auth != null &&
                       request.resource.data.user_id == request.auth.uid &&
                       isValidBriefData(request.resource.data) &&
                       isValidClientSessionId(request.resource.data.client_session_id) &&
                       areValidActions(request.resource.data.actions) &&
                       request.resource.data.decisions.size() <= 100 &&
                       request.resource.data.questions.size() <= 100;
      
      // Allow update only for owner with same client session
      allow update: if request.auth != null &&
                       isOwner(resource) &&
                       request.resource.data.user_id == request.auth.uid &&
                       resource.data.client_session_id == request.resource.data.client_session_id &&
                       isValidBriefData(request.resource.data) &&
                       areValidActions(request.resource.data.actions);
      
      // Allow delete only for owner
      allow delete: if request.auth != null &&
                       isOwner(resource);
    }
    
    // Rules for user profiles (if needed)
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Deny access to all other collections and documents
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

// PRODUCTION SECURITY FEATURES:
// 1. Requires user authentication (Firebase Auth or Google Cloud Identity)
// 2. Users can only access their own briefs
// 3. Validates all data structure and types
// 4. Enforces business logic constraints
// 5. Prevents unauthorized cross-user access
// 6. Includes user_id field for ownership tracking
// 7. Comprehensive data validation

// MIGRATION FROM DEVELOPMENT:
// 1. Add user authentication to your app
// 2. Include user_id field in brief documents
// 3. Update backend to use authenticated user IDs
// 4. Replace development rules with these production rules

// AUTHENTICATION INTEGRATION:
// - Use Firebase Authentication or Google Cloud Identity Platform
// - The request.auth.uid will contain the authenticated user's ID
// - Ensure your backend sets the user_id field correctly
